\documentclass[12pt]{report}

\usepackage{amsmath}
\usepackage{pgfplots}
\usepgfplotslibrary{units}
\usepackage[russian]{babel}
\usepackage{filecontents}
\usepackage{titlesec, blindtext, color}
\usepackage{listings}
\usepackage{pdfpages}
\usepackage[normalem]{ulem}

\ULdepth = 0.16em
	
\usepackage{indentfirst}


\usepackage{titlesec, blindtext, color} 
\definecolor{gray75}{gray}{0.75} 
\newcommand{\hsp}{\hspace{20pt}} 

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

\usepackage{geometry}
\geometry{top=2cm}
\geometry{left=2cm}
\geometry{right=1cm}
\geometry{bottom=2cm}

\lstset{
	language=C++,
	numbers=left,
	breaklines=true, 
	frame=single,
	texcl=true,
	basicstyle=\ttfamily,
	extendedchars=\true
}

\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}

\begin{filecontents}{ZG1.dat}
	160000 0.21
	320000 0.261 
	560000 0.306
	880000 0.411
	1280000 0.573
	2480000 1.526 
	3280000 2.688
	3680000 3.166
	4080000 3.91
\end{filecontents}

\begin{filecontents}{ZPH1.dat}
	160000 0.51
	320000 0.555
	560000 0.718
	880000 0.904
	1280000 1.128
	2480000 2.149 
	3280000 2.934
	3680000 3.161
	4080000 3.669
\end{filecontents}

\begin{filecontents}{RT1.dat}
	160000 1.261
	320000 1.271
	560000 1.356
	880000 1.514
	1280000 1.684
	2480000 1.972
	3280000 2.073
	3680000 2.131
	4080000 2.132
\end{filecontents}

\begin{filecontents}{RT2.dat}
	24 1.675
	48 3.095
	60 3.793
	72 4.609
	84 5.155
\end{filecontents}

\begin{filecontents}{ZPH2.dat}
	24 0.245
	48 0.485
	60 0.593
	72 0.702
	84 0.751
\end{filecontents}

\begin{filecontents}{ZG2.dat}
	24 0.348
	48 0.242
	60 0.247
	72 0.25
	84 0.259
\end{filecontents}



\begin{document}

	a
	\newpage
	b
	\newpage
	\tableofcontents
	\chapter*{Введение}
	\addcontentsline{toc}{chapter}{Введение}
	В наше время одна из основных задач компьютерной графики состоит в создании и развитии алгоритмов построения реалистичных изображений. Данные алгоритмы используются повсеместно, например: компьютерные игры, дизайн, кинематограф и т.д. 
	
	Для построения изображения, максимально похожего на то, что мы видим в реальной жизни, необходимо учитывать такие явления как: преломление, отражение, рассеивание света и многие другие.
	
	На данный момент существует множество алгоритмов для синтеза реалистичного изображения, каждый из которых имеет свои достоинства и недостатки. 
	
	\textbf{Цель данной работы} - реализовать и сравнить алгоритм Z-буфера с закраской по Гуро, алгоритм Z-буфера с закраской по Фонгу и алгоритм обратной трассировки лучей.
	
	Для достижения поставленной задачи необходимо:
	\begin{enumerate}
		\item проанализировать рассматриваемы алгоритмы компьютерной графики;
		\item реализовать данные алгоритмы;
		\item провести сравнительный анализ.
	\end{enumerate}

	Итогом работы над данным проектом должны стать программа, демострирующая работу этих алгоритмов, а также выводы, сделанные на основе проведенного сравнительного анализа.
	
	\chapter{Аналитическая часть}
	\section{Формализация сцены}
	
		На сцене могут располагаться некоторые колличество геометрических объектов: икосаэдров, параллелипипедов и прямых трехгранных призм. Положение и размер икосаэдра должен задаваться координатами центра описанной окружности и её радиусом, параллелипипеда - также координатами центра, шириной, высотой и глубиной, прямой трехгранной призмы - так же как и параллелипипеда.
		
		Каждый объект обладает характеристиками: цвет, коэффициент рассеивания, коэффициент отражения, коэффициент блеска.
		
		На сцене также могут находиться некоторые количество точечных источников света. Каждый источник задается координатой в пространстве и интенсивность.
		
	\section{Представление объектов сцены}
	
	Необходимо выбрать модель представления объектов на сцене. Для реализации поставленной задачи предпочтительнее будет использовать поверхностные модели, так как для синтеза реалистичного изображения необходимо знать только внешний вид изображаемого объекта.
	
	Для задания поверхностной модели я буду использовать полигональную сетку. Полигональная сетка – представление поверхности геометрического объекта в виде набора состыкованных друг с другом плоских полигонов. В качестве полигонов мою были выбраны треугольники, так как это, в дальнейшем, упростит производимые расчеты.
	
	Существует множество представлений полигональной сетки. Ниже я рассмотрю четыре основных представления: Вершинное, Список граней, «Крылатое» и Веер треугольников.[1]
	
	\begin{itemize}
		\item Вершинное представление – описывает объект как множество вершин, соединенных с другими вершинами. Дает выигрыш по памяти, но проигрыш в скорости обхода.
		\item Список граней – представляет объект как множество граней и множество вершин. Требует больше памяти, чем вершинное представление, но позволяет находить соседние грани и вершины за постоянное время.
		\item «Крылатое» представление – явно представляет вершины, грани и ребра сетки. Требует значительно больше памяти чем список граней и вершинное представление, но позволяет увеличить скорость обхода сетки.
		\item Веер треугольников – описывает множество соединенных треугольников, которые делят одну центральную вершину. Данное представление требует мало памяти и позволяет производить быстрый обход сетки, но требует больших затрат при изменении.
	\end{itemize}

	В данной работе мною будет использован список граней, так как я считаю, что в данной работе допустимо пренебречь дополнительными затратами по памяти ради уменьшения затрат на написания программного продукта.

	\section{Анализ рассматриваемых алгоритмов}
	
	\subsection{Алгоритм, использующий Z-буфер}
	
	Идея алгоритма, использующего Z-буфер, заключается в наличии двух буферов: буфер кадра и буфер глубины (он же Z-буфер). В первом хранится информация об атрибутах каждого пикселя экрана. Второй используется для хранения Z координаты каждого пикселя.[2]
	
	Перед началом работы данного алгоритма, каждый, находящийся на сцене объект, переводится в растр. Далее необходимо пройти по всем пикселям каждого объекта. В процессе прохода координата Z каждого нового пикселя сравнивается со значением, записанным в Z-буфере. Если сравнение показывает, что Z координата нового пикселя больше записанного, то новый пиксель заносится в буфер кадра. Также производится запись новой координаты Z в соответствующее значение Z-буфера. В ином случае никаких действий не производится.
	
	Основное преимущество этого алгоритма заключается в его простоте. Также он позволяет обрабатывать объекты в произвольном порядке, что позволяет экономить время, затрачиваемое на сортировку по глубине.
	
	Основной недостаток алгоритма – большой объем требуемой памяти. Другой недостаток заключается в трудоемкости реализации эффектов прозрачности и просвечивания.

	\subsection{Метод Гуро}

	Метод Гуро – метод закрашивания в трехмерной компьютерной графики (так же еще называют методом затемнения и сглаживания). 
	Данный метод основывается на идеи закрашивания каждого полигона не одним цветом, а плавно изменяющимися оттенками, вычисляемыми путем интерполяции цветов примыкающих граней. Так как в нашем случае каждая грань является треугольником, достаточно вычеслить освещенность в каждой вершине и далее путем билинейной интерполяции находить освещенность в каждой точке грани.[3]
	
	К недостаткам метода Гуро относят то, что он хорошо работает только с диффузной моделью отражения. 

	\subsection{Метод Фонга}
	Метод Фонга – также является методом закрашивания (затемнения, сглаживания), основой которого является интерполяция векторов нормалей. В нашем случае объект представляет собой множество плоских граней, соответственно для реализации метода Фонга достаточно найти нормаль в каждой грани, и на её основе вычислять освещенность для каждого пикселя.[4]
	
	Этот метод требует больших вычислительных затрат, чем метод Гуро, но дает в итоге позволяет получить более качественное изображение, так как в данном методе освещенность вычислется для пикселя грани, а не только для её вершин, как в метода Гуро.
	
	\subsection{Растровая развертка треугольника}
	
	Для разложения треугольница в растр изначально производится одновременное разложение в растр двух ребер рассматриваемого треугольника методом цифрового дифференциального анализатора (ЦДА)[5]. При вычислении новых значений точек, принадлежащих кадому из отрезков, производится разложение в растр отрезка, полученного из двух найденных точек. Таким образом получается найти все точки принадлежащие рассматриваемому треугольнику.
	
	На данном рисунке точки $a$, $b$, $c$ это точки образующие треугольник. Точка $ab'$ - это точка принадлежащая отрезку $ab$, полученная в результате перевода в раст этого отрезка. Точка $ac'$ - точка, соответственно, принадлежащая отрезку $ac$. Стрелочками показано направление движение при переводе в растр.
	\begin{center}
		\includegraphics[scale=0.7]{cda.png}
		
		Рисунок. 1.1. Пример разложения треугольника в растр.
	\end{center}
	
	\subsection{Обратная трассировка лучей}
	Идея обратной трассировки лучей заключается в том, что из виртуального глаза, находящегося на некотором расстоянии от экрана, испускается луч и находится точка его пересечения с объектом сцены. Далее определяется освещенность найденной точки. Делается это путем испускания из данной точки лучей ко всем источникам света и определения их вклада в общую освещенность. Далее из найденной точки пересечения рекурсивно испукается отраженный луч, для поиска объектов, отражающихся в данном. Данный процесс повторяется до тех пор, пока луч не выходит за пределы сцены. Также этот процесс можно ограничить максимальной глубиной рекурсии.[6]
	
	Данный алгоритм позволяет не только закрашивать объекты, но также и определять их видимость, что делает его достаточно универсальным.
	Достоинства обратной трассировки лучей:
	\begin{itemize}
		\item возможность рендеринга гладких объектов без их предварительной аппроксимации;
		\item возможность эффективного распараллеливания вычислений.
	\end{itemize}

	Основным недостатком этого алгоритма является относительно низкая производительность.
	
	\section*{Вывод}
	\addcontentsline{toc}{section}{Вывод}
	
	В данном разделе осуществлен выбор способа хранения информации об объектах. Выбор пал на список граней, так как он позволяет уменьшить затраты на написание программного продукта из-за простоты своей реализации. На ряду с этим описанны рассматриваемые алгоритмы.
	
	\chapter{Конструкторская часть}
	\section{Модель освещения Фонга}
	
	В данной работе было решено использовать модель освещения Фонга[5]. Данная модель учитывает три компоненты освещения: Фоновую (ambient), рассеянную (diffuse) и зеркальную (specular).
		
	Фоновое освещение присутствует в любом уголке сцены. Это происходит из-за многократного отражения лучей света от окружающих объектов. 
		
	Рассеянное освещение – тот свет, что отражается от поверхности во всех направлениях.
	
	Зеркальное освещение – часть отраженных лучей, попадающих в глаза наблюдателю.
	
	Для вычисления общей освещенности от одного точечного источки в некоторой точке пространства будет использована формула:
	\begin{equation}
		I = I_{a} + K_{d}*(\overline{n}, \overline{l})*I_{n} + K_{s}*(\overline{V}, \overline{R})^{p}*I_{n}
	\end{equation}
		
		$I_{a}$ - интенсивность фонового освещения
		
		$K_{d}$ - коэффициент рассеянного освещения
		
		$K_{s}$ - коэффициент зеркального освещения
		
		$P$ - коэффициент блеска
		
		$I_{n}$ - мощность n-го источника света, расчитывается как
		
		$\overline{n}, \overline{l}, \overline{V}, \overline{R}$ - единичные вектора. Нормаль, до источника света, до точки наблюдения, отраженного луча. 
		~\\
		
		Если источников больше одного, тогда для вычисления итоговой освещенности необходимо сложить вклад в рассеянное и зеркальное отражение каждого источника.
	\newpage	
	\section{Метод Гуро}
	
	Описание алгоритма:
	
	\begin{enumerate}
		\item расчитать нормаль к каждой грани (так как в данном случае каждая грань является треугольником, нормаль можно вычислить путем векторного произведения двух сторон);
		\item определить нормаль в вершинах рассматриваемой грани, путем усреднения нормалей примыкающих граней;	
		\item закрасить грань цветом, соответствующим билинейной интерполяции значений интенсивности в вершинах.
	\end{enumerate}

	Рассмотрим билинейную интерполяцию интенсивностей.
	
	\begin{center}
		\includegraphics[scale=1]{gourand.png}
		
		Рисунок 2.1. Пример билинейной интерполяции интенсивностей.
	\end{center}

	Интенсивность $I$ определяется исходя из пропорции:
	\begin{equation}
		(I - I_{1})/(X - X_{1}) = (I_{2} - I_{1})/(X_{2} - X_{1})
	\end{equation}
	Отсюда следует:
	\begin{equation}
		I = I_{1} + (I_{2} - I_{1})(X - X_{1})/(X_{2} - X_{1})
	\end{equation}
	
	Значения $I_{1}$, $I_{2}$ расчитываются как:
	\begin{equation}
		I_{1} = I_{b} + (I_{c} - I_{b})(Y - Y_{b})/(Y_{c} - Y_{b})
	\end{equation}
	\begin{equation}
		I_{2} = I_{b} + (I_{a} - I_{b})(Y - Y_{b})/(Y_{a} - Y_{b})
	\end{equation}

	\begin{center}
		\includegraphics[scale=0.6]{gourandBS.png}
		
		Рисунок 2.2. Схема алгоритма закраси Гуро.
	\end{center}
	
	\section{Метод Фонга}
	
	Описание алгоритма:
	\begin{enumerate}
		\item вычисление нормали к рассматриваемой грани;
		\item произвести расчет освещенности каждого пикселя грани, на основе вычисленной нормали.
	\end{enumerate}

	\section{Алгоритм, использующий Z-буфер}
	
	Описание алгоритма:
	\begin{enumerate}
		\item элементам буфера кадра присвоить значение цвета фона;
		\item элементам Z-буфера присвоить минимальное значение типа данных;
		\item для каждого треугольника, кажого объекта на сцене:
		\begin{enumerate}
			\item выполнить растровую развертку треугольника;
			\item для каждого пикселя, принадлежащего грани, сравнить координату Z с соответствующим значением, хранящемся в Z-буфере:
			\begin{enumerate}
				\item если больше: 
				\begin{enumerate}
					\item в буфер кадра записать атрибуты рассматриваемого пикселя (по соответствующим X, Y);
					\item записать значение координаты Z рассматриваемого пикселя в Z-буфер (по соответствующим X, Y);
				\end{enumerate}	
			\end{enumerate}
		\end{enumerate}
		\item отобразить полученное изображение.
	\end{enumerate}

	\begin{center}
		\includegraphics[scale=0.5]{zbuffBS.png}
		
		Рисунок 2.3. Схема алгоритма, использующего Z-буфер.
	\end{center}

	\section{Растровая развертка треугольника}
	
	Пусть треугольник задается тремя точками $A$, $B$, $C$.
	
	Описание алгоритма:
	\begin{enumerate}
		\item найти единичный вектор движения вдоль отрезка $AB$, как $\frac{\overline{AB}}{|\overline{AB}|}$;
		\item найти единичный вектор движения вдоль отрезка $AC$, как $\frac{\overline{AC}}{|\overline{AC}|}$;
		\item инициализировать начальную точку для движения вдоль $AB$, $T1 = A$;
		\item инициализировать начальную точку для движения вдоль $AC$, $T2 = A$;
		\item пока точка $T1 != B$ и $T2 != C$
		\begin{enumerate}
			\item перевести в растр отрезок $T1T2$;
			\item сместить $T1$ на $\frac{\overline{AB}}{|\overline{AB}|}$, $T2$ на $\frac{\overline{AC}}{|\overline{AC}|}$;
		\end{enumerate}
		\item отобразить полученное изображение.
	\end{enumerate}

	\section{Обратная трассировка лучей}

	Описание алгоритма:
	\begin{enumerate}
		\item для каждого пикселя экрана:
		\begin{enumerate}
			\item задать направление пускаемого луча, как $\frac{\overline{VP}}{|\overline{VP}|}$, $V$ - точка наблюдателя, $P$ - текущая точка экрана
			\item для каждого объекта сцены:
			\begin{enumerate}
				\item найти пересечения со сферой, описанной вокруг объекта;
				\item если пересечение есть, найти точку пересечения с каждой гранью этого объекта:
				\item если точка есть:
				\begin{enumerate}
					\item расчитать освещенность найденной точки;
					\item если не достигнута максимальная глубина рекурсии, рекурсивно пустить отраженный луч и прибавить найденное значение к текущему цвету пикселя;
				\end{enumerate}
				\item иначе установить цвет пикселя равному цвету фона;
			\end{enumerate}
			\item закрасить текущую точку экрана соотвествуя найденному значению;
		\end{enumerate}
	\end{enumerate}	

	\begin{center}
		\includegraphics[scale=0.5]{rtBS.png}
		
		Рисунок 2.5. Схема алгоритма обратной трассировки лучей.
	\end{center}
	\newpage
	\section{Поиск пересечения луча со сферой}
	
	Луч задается уравнением:
	\begin{equation}
		\overline{r} = \overline{o} + t*\overline{d}
	\end{equation}
	
	$t \in R, t >= 0$
	
	$\overline{o}$ - начальная точка луча
	
	$\overline{d}$ - направление луча
	
	Координаты этого луча можно записать как:
	\begin{equation}
		X = X_{o} + t*X_{d}
	\end{equation}
	\begin{equation}
		Y = Y_{o} + t*Y_{d}
	\end{equation}
	\begin{equation}
		Z = Z_{o} + t*Z_{d}
	\end{equation}
	
	Сфера задается уравнением:
		
	\begin{equation}
		(X - X_{c})^2 + (Y - Y_{c})^2 + (Z - Z_{c})^2 = R^2
	\end{equation}
	
	Для того, чтобы найти пересечение луча со сферой необходимо в уравнение сферы подставить соотвествующие координаты луча.
	
	После подстановки и несложных преобразований можно получить:
	\begin{equation}
		t^2 + B*t + C = 0
	\end{equation}
	
	Где,
	\begin{equation}
		B = 2(X_{d}*(X_{o} - X_{c}) + Y_{d}*(Y_{o} - Y_{c}) + Z_{d}*(Z_{o} - Z_{c}))
	\end{equation}
	
	\begin{equation}
		C = (X_{o} - X_{c})^2 + (Y_{o} - Y_{c})^2 + (Z_{o} - Z_{c})^2 - R^2
	\end{equation}
	
	Если дискриминант этого уравнения меньше нуля, тогда луч не пересекается со сферой. Иначе найденные корни будут являться параметрами, которые необходимо подставить в уравнение (2.6) для того, чтобы найти необходимые точки пересечения.
	
	При написании данной работы поиск пересечения со сферой необходим для оптимизации работы обратной трассировки лучей. В этом случае нас интерисует только факт того, есть пересечение или нет, соответственно достатоно лишь проверить знак дескрименанта.
	
	\section{Поиск пересечения луча с треугольником}
	
	Пусть луч задается так же, как и при поиске пересечения со сферой (2.6).
	
	Тогда для поиска пересечения с треугольником, изначально необходимо найти точку пересечения этого луча с плоскостью, образованной этим треугольником.
	
	Точка $\overline{p}$ лежит в плоскости, если $(\overline{p} - \overline{q})*\overline{n} = 0$. 
	
	$\overline{n}$ - нормаль к плоскости.
	
	Если подставить вместо $\overline{r}$ координаты луча и выразить параметр, то можно получить:
	\begin{equation}
		t = \frac{(\overline{q} - \overline{o})*\overline{n}}{\overline{d}*\overline{n}}
	\end{equation}
	
	Если $t$ < 0, то точки пересечения нет, иначе $\overline{r} = \overline{o} + t*\overline{d}$ искомая точка пересечения.
	
	Далее необходимо определить, принадлежит ли найденная точка, если таковая имеется, треугольнику.
	
	Пусть треугольник задается тремя точками $A$, $B$, $C$, а найденную точку назовем $P$.
	
	Тогда, если результат трех векторных произведений $\overline{AB}$x$\overline{AP}$, $\overline{BC}$x$\overline{BP}$ и $\overline{CA}x\overline{CD}$ будут сонаправлены, то точка $P$ лежит внутри треугольника $ABC$. Сонаправленность можно проверить путем сравнения знака соответсвующих координат полученных векторов.
	
	\section{Поиск отраженного луча}

	Отраженный луч ищется как:
	\begin{equation}
		\overline{r} = \overline{d} - 2\overline{n}*(\overline{d}*\overline{n})
	\end{equation}
	
	$\overline{d}$ - направление падающего луча
	
	$\overline{n}$ - нормаль в точке падения

	\section*{Вывод}
	\addcontentsline{toc}{section}{Вывод}

	В данном разделе описаны принципы работы всех рассматриваемых алгоритмов, а также необходимые для расчетов математические соотношения.
	
	\chapter{Технологическая часть}
	
	\section{Выбор языка и среды программирования}
	
		Для реализации данного программного продукта был выбран язык C++ [7], так как имеется наибольший опыт работы с данным языком.
		
		Также была выбрана объектно-ориентированная технология из-за её гибкости и из-за того что она предоставляет возможность вносить правки в уже написанный код без необходимости переписывания больших его частей.
		
		Для реализации интерфейса был выбран фреймворк QT [8], так как он предоставляет большой спектр возможностей для создания сложных интерфейсов.
		
		C++ предоставляет доступ к библиотекам для параллельного программирования. В данной работе будут использованы <thread> [9] для создания параллельных потоков и <mutex> [10] для ограничения доступа к ресурсам.
		
	\section{Замеры времени}
	Замер времени работы алгоритмов производился при помощи функций clock() из библиотеки time.h. [11]
	
	\newpage
	\section{Интерфейс программы}
	
	На Рисунке. 3.1. представлен пользовательский интерфейс программы. Слева - инструментарий для редактирования сцены, справа синтезированное изображение.
	
	\begin{center}
		\includegraphics[scale=0.45]{UI.png}
		
		Рисунок. 3.1. Интерфейс программы
	\end{center}	

	
	На Рисунке. 3.2. - Рисунке. 3.4. изображены окна добавления объектов на сцену.
	Каждое окно имеет поля для ввода:
	\begin{enumerate}
		\item центра фигуры;
		\item цвета фигуры;
		\item коэффициента диффузного и зеркально освещения;
		\item коэффициент блеска;
		\item параметры, необходымые для задания размеров объекта (Радиус для икосаэдра, Ширина, Высота и Глубина для параллелепипеда и прямой треугольной призмы)
	\end{enumerate}

	На Рисунке. 3.5. изображено окно добавления источника света. Данное окно обладает полями для ввода координаты источника и его интенсивности.
	
	Переключение между окнами происходит при помощи стрелок, расположенных в правом верхнем углу.
	
	~\\
	
	\begin{minipage}{0.5\textwidth}
		%\flushleft
			\begin{center}
				\includegraphics[scale=0.8]{ico.png}
				
				Рисунок. 3.2. Окно добавление икосаэдра
			\end{center}
	\end{minipage}
	\hfill
	\begin{minipage}{0.5\textwidth}
		\begin{center}
			\includegraphics[scale=0.8]{prism.png}
			
			Рисунок. 3.4. Окно добавление трехгранной прямой призмы
		\end{center}
	\end{minipage}

		\begin{minipage}{0.5\textwidth}
		%\flushleft
		\begin{center}
			\includegraphics[scale=0.8]{paral.png}
			
			Рисунок. 3.3. Окно добавление параллелепипеда
		\end{center}
	\end{minipage}
	\hfill
	\begin{minipage}{0.5\textwidth}
		\begin{center}
			\includegraphics[scale=0.8]{lt.png}
			
			Рисунок. 3.5. Окно добавление источника света
		\end{center}
	\end{minipage}

	На Рисунке. 3.6. изображены поля, предоставляющие доступ для изменения и удаления объектов, уже находящихся на сцене.
	
	Все созданные объекты добавляются в список, далее можно выбрать объект из этого списка и удалить или повращать его.
	
	Источники света добавляются в отдельный список, их можно только удалять.

	\begin{center}
		\includegraphics[scale=1]{changes.png}
		
		Рисунок. 3.6. Поля для изменения созданных объектов
	\end{center}
	
	На Рисунке. 3.7 изображены поля для выбора способа синтеза изображения.
	
	Поле Глубина отвечает за максимальную глубину отражения при поиске отраженных лучшей для алгоритма обратной трассировки лучей.
	
	Поле Потоки отвечает за то, на сколько потоков будет делиться процесс при синтезе изображения.
	
	\begin{center}
		\includegraphics[scale=1]{choose.png}
		
		Рисунок. 3.7. Поля для выбора способо синтеза изображения
	\end{center}

	\section*{Вывод}
	\addcontentsline{toc}{section}{Вывод}
	
	В данном разделе обоснован выбор языка программирования, описаны выбранные средства для создания интерфейса, а так как же описано строение пользовательского интерфейса.


	\chapter{Экспериментальная часть}
	
	\section{Цель эксперимента}
	
	Целью эксперимента является временное сравнение работы реализованных алгоритмов.
	
	\section{Апробация}
	
	На Рисунке 4.1. представлена сцена, содержащая куб, икосаэдр, трехгранную призму и один точечный источник. Это изображение сгенерировано обратной трассировкой лучей.
	
	\begin{center}
		\includegraphics[scale=0.8]{rt.png}
		
		Рисунок. 4.1. Сцена, сгенерированая обратной трассировкой лучей.
	\end{center}

	На Рисунке 4.2. изображена та же самая сцена, сгенерированная обратной трассировкой, но с дополнительным вычислением отражений.
	
	\begin{center}
		\includegraphics[scale=0.8]{rto.png}
		
		Рисунок. 4.2. Сцена, сгенерированая обратной трассировкой лучей с дополнительным вычислением отражений.
	\end{center}

	На Рисунке 4.3. показана сцена, сгенерированная с использованием Z-буфера и метода Фонга.

	\begin{center}
		\includegraphics[scale=0.8]{gph.png}
		
		Рисунок. 4.3. Сцена, сгенерированая с использованием Z-буфера и метода Фонга.
	\end{center}

	На Рисунке 4.4. изображена сцена, сгенерированная с использованием Z-буфера и метода Гуро.

	\begin{center}
		\includegraphics[scale=0.8]{zg.png}
		
		Рисунок. 4.4. Сцена, сгенерированая с использованием Z-буфера и метода Гуро.
	\end{center}

	\section{Описание эксперимента}
	
	Суть эксперимента заключается в том, чтобы замерить скорость работы алгоритмов в 
	двух различных случаях.
	
	Первый случай - когда суммарное колличество граней объектов на сцене не изменяется, увеличивается лишь суммарная площадь этих граней. В теории этот случай должен быть благоприятен для использования трассировки лучей.
	
	Второй - обратный первому, когда увеличивается суммарное колличество граней при неизменной площади. В теории этот случай должен быть благоприятен для использования Z-буфера с Фонгом или же с Гуро.
	
	Все эксперементы проведены в однопоточном режиме.
	
	Эксперимент проводоился на следующей системе:
	\begin{enumerate}
		\item Intel(R) Core(TM) i7-3770K
		\item 8.00 ГБ ОЗУ
	\end{enumerate}

	\subsection{Первый случай}
	
	В данном случае на сцену добавлен один объект - парраллелипипед, содержащий 12 треугольников - граней.
	Во время эксперимента изменялись длины ребер, в следствии чего менялась площадь объекта.
	
	Новых объектов не добавлялось, соответственно суммарное колличество граней не изменялось.
	~\\	
	
	Таблица. 4.1. Времена работы алгоритмов при различных суммарных площадях.
	
	\begin{center}
		\begin{tabular}{|c c c c|}
			\hline
			Площадь (px) & Z+gourand (c) & Z+phong (c) & RayTrace (c) \\ [0.5ex]
			\hline
			160000 & 0.21 & 0.51 & 1.261 \\ 
			\hline 
			320000 & 0.261 & 0.555 & 1.271 \\ 
			\hline 
			560000 & 0.306 & 0.718 & 1.356 \\ 
			\hline 
			880000 & 0.411 & 0.904 & 1.514 \\ 
			\hline 
			1280000 & 0.573 & 1.128 & 1.684 \\ 
			\hline 
			2480000 & 1.526 & 2.149 & 1.972 \\ 
			\hline 
			3280000 & 2.688 & 2.934 & 2.073 \\
			\hline
			3680000 & 3.166 & 3.161 & 2.131 \\
			\hline
			4080000 & 3.91 & 3.669 & 2.132 \\
			\hline 
		\end{tabular}
	\end{center}

	\begin{center}
		\begin{center}
			\begin{tikzpicture}
			\begin{axis}[
			axis lines = left,
			xlabel = $\texttt{Площадь (px)}$,
			ylabel = $\texttt{Время (сек.)}$,
			legend pos=outer north east,
			ymajorgrids=true
			]
			
			\addplot[color=green] table[x index=0, y index=1] {RT1.dat};
			\addplot[color=blue] table[x index=0, y index=1] {ZPH1.dat};
			\addplot[color=red] table[x index=0, y index=1] {ZG1.dat};
			
			\addlegendentry{RayTrace}
			\addlegendentry{Z-buff + Phong}
			\addlegendentry{Z-buff + gourand}
			\end{axis}
			\end{tikzpicture}
		\end{center}
		Рисунок. 4.5. График сравнения алгоритмов при различных суммарных площадях. (Таблица 4.1.)
	\end{center}

	Из Рисунка 4.5. видно, как при сильном увеличении суммарной площади без увеличения колличества граней на сцене, трассировка лучей начинает выигрывать у Z-буфера с Гуро и Z-буфера с Фонгом. (Рис. 4.5.)
	
	Это связано с тем, что алгоритм Z-буфера переводит в растр все грани каждого объекта, соотвественно при увеличении площади увеливается и трудоемкость.
	
	В то же время обратная трассировка лучей лишь находит точку пересечения с гранью и никак не зависит от её площади.
	
	\uline{Из этого эксперимента можно сделать вывод, что обратную трассировку лучей выгоднее использовать для синтеза сцены, на которой малое колличество граней и их суммарная площадь очень велика.}

	
	По данным Таблицы 4.1. видно, что трассировка начала работать быстрее только при суммарной площади равной 3280000 px. При таком значении трассировка быстрее алгоритмов с Z-буфером приверно в 1.45 раз.
	Также можно заметить, что при площаде равной 3680000 px скорость работы алгоритмов Z-буфера с закраской по Фонгу и по Гуро сравнялись, а при площаде равной 4080000 px алгоритм Z-буфера с закраской по методу Гуро начал работать на 6\% медленнее Z-буфера с Фонгом.
	
	\textbf{Вывод по первому случаю:} в данном случае лучшее время работы показала обратная трассировка лучей, худшее - Z-буфер с методом закраски по Гуро.
	
	\subsection{Второй случай}
	
	В данном случае площадь зафиксированна в значении 60000 px. На этот раз добавляются новые объекты, тем самым увеличивая суммарное колличество граней.
	~\\
	
		Таблица. 4.2. Времена работы алгоритмов при увелечении количества граней.
	
	\begin{center}
		\begin{tabular}{|c c c c|}
			\hline
			Кол-во граней & Z+gourand (c) & Z+phong (c) & RayTrace (c) \\ [0.5ex]
			\hline
			24 & 0.348 & 0.245 & 1.675 \\ 
			\hline 
			48 & 0.242 & 0.485 & 3.095 \\ 
			\hline 
			60 & 0.247 & 0.593 & 3.793 \\ 
			\hline 
			72 & 0.25 & 0.702 & 4.609 \\ 
			\hline 
			84 & 0.259 & 0.751 & 5.155 \\ 
			\hline
		\end{tabular}
	\end{center}
	~\\

	\begin{center}
		\begin{center}
			\begin{tikzpicture}
			\begin{axis}[
			axis lines = left,
			xlabel = $\texttt{Кол-во ребер}$,
			ylabel = $\texttt{Время (сек.)}$,
			legend pos=outer north east,
			ymajorgrids=true
			]
			
			\addplot[color=green] table[x index=0, y index=1] {RT2.dat};
			\addplot[color=blue] table[x index=0, y index=1] {ZPH2.dat};
			\addplot[color=red] table[x index=0, y index=1] {ZG2.dat};
			
			\addlegendentry{RayTrace}
			\addlegendentry{Z-buff + Phong}
			\addlegendentry{Z-buff + gourand}
			\end{axis}
			\end{tikzpicture}
		\end{center}
		Рисунок. 4.6. График сравнения алгоритмов при увеличении количества граней.
	\end{center}

	Из Рисунка 4.6. видно, что при большом колличестве граней трассировка лучей начинает проигрывать алгоритмам с Z-буфером. Согласно Таблице 4.2., при 24 гранях трассировка работает в 6 раз медленее Z-буфера с Фонгом и в 4 раза медленее Z-буфера с Гуро. При 84 гранях разница состовляет уже 6,8 раз и 19 раз соответственно. При 84 гранях Z-буфер с Фонгом работает в 2.9 раза быстрее чем Z-буфер с Гуро.
	
	\textbf{Вывод по второму случаю:} в данном случае лучшее время работы показал метод Z-буфера с закраской по Гуро, худшее - обратная трассировка лучшей.
	\newpage
	\section*{Вывод}
	\addcontentsline{toc}{section}{Вывод}
	
	В данном разделе проведен эксперимент, в котором рассматривается два случая.
	
	В первом случае, при увеличении суммарной площади граней всех объектов на сцене, показано, что обратная трассировка лучей демонстрирует наилучший результат, по сравнению с алгоритмами использующими Z-буфер, при превышении суммарной площади значения, равного 3280000 px.
	
	Также замечено, что при превышении суммарной площади значения, равного 3680000 px Z-буфер с методом Гуро начал уступать по времени Z-буферу с методом Фонга. При 4080000 px разница достигла 6\%.
	
	Во втором случае, при увеличении количества граней с неизменной их суммарной площадью, показано, что алгоритм Z-буфера с закраской по Гуро демонстрирует наилучший результат, по сравнению с остальными рассматриваемыми алгоритмами. В среднем, Z-буфер с закраской по Гуро работает в 2 раза быстрее Z-буфера с закраской по Фонгу, а так же в 12 раз быстрее обратной трассировки лучей.
	
	Исходя из данных полученных в этом разделе, можно сделать вывод, что:
	\begin{enumerate}
		\item алгоритм обратной трассировки лучей является наиболее быстрым, в случае наличия на сцене объектов с малым количеством граней, но большой площадью;
		\item алгоритм Z-буфера с методом закраски Гуро является наиболее быстрым, в случае наличия на сцене объектов с большим количеством граней и малой площадью;
		\item изображения, синтезируемые методом Z-буфера с закраской по Фонгу и обратной трассировки лучей, практически не отличаются визуально;
		\item отражения в объектах позволяет строить только метод обратной трассировки лучей.
	\end{enumerate}
	
	\chapter*{Заключение}
	\addcontentsline{toc}{chapter}{Заключение}

	В рамках данной работы проанализированы рассматриваемые алгоритмы компьютерной графики для постоения реалистичных изображений. Был выбран оптимальный формат для хранения информации об объектах. Также были получены и описаны все необходимые, для решения поставленной задачи, математические соотношения.
	
	В результате был написан программный продукт для генерации реалистичного изображения и проведет анализ рассматриваемых алгоритмов. Анализ проводился на основе проведенного эксперимента, в котором рассматривались два возможных случая.
	
	Первый случай, при котором синтезируемая сцена содержит малое количество объектв, следовательно и малое количество граней, но суммарная площадь всех этих граней очень велика. В данном случае лучшее время работы показала обратная трассировка лучшей, худшее - Z-буфер с методом закраски по Гуро.
	
	Второй случай, при котором синтезируемая сцена содержит объекты с большим количеством граней, но суммарная площадь этих граней мала. В данном случае лучшее время работы показал метод Z-буфера с закраской по Гуро, худшее - обратная трассировка лучей.
	
	В результате проведенного анализа, полученно:
	\begin{enumerate}
		\item алгоритм обратной трассировки лучей является наиболее быстрым, в случае наличия на сцене объектов с малым количеством граней, но большой площадью;
		\item алгоритм Z-буфера с методом закраски Гуро является наиболее быстрым, в случае наличия на сцене объектов с большим количеством граней и малой площадью;
		\item изображения, синтезируемые методом Z-буфера с закраской по Фонгу и обратной трассировки лучей, практически не отличаются визуально;
		\item отражения в объектах позволяет строить только метод обратной трассировки лучей.
	\end{enumerate}

	\chapter*{Литература}
	\addcontentsline{toc}{chapter}{Заключение}
	
	\begin{enumerate}
		\item Косников Ю.Н. Поверхностные модели в системах трехмерной компьютерной графики. Учебное пособие. – Пенза: Пензенский государственный университет, 2008. – 60 с.
		
		\item Роджерс, Д.Ф. Алгоритмические основы машинной графики / Пер. с англ.
		С.А. Вичеса, Г.В. Олохтоновой, П.А. Монахова. – М.: Мир: 1989. – 512 с.
		– ISBN 5-03-000476-9;
		
		\item Закраска методом Гуро. [Электронный ресурс]
		
		 Режим доступа: http://www.mari-el.ru/mmlab/home/kg/Lection11/3.html Последняя дата обращения: 25.12.2019
		
		\item Особенности моделирования света: Аппроксимации Фонга (Phong Shading). [Электронный ресурс] 
		
		Режим доступа: https://www.ixbt.com/video/light-model-phong.html Последняя дата обращения: 25.12.2019
		
		\item Закон Ламберта. Модель отражения Фонга. Модель отражения Блинна-Фонга.
		[Электронный ресурс] 
		
		Режим доступа: https://compgraphics.info/3D/lighting/phong\_reflection\_model.php Последняя дата обращения: 25.12.2019
		
		\item Вельтмандер П.В. Основные алгоритмы компьютерной графики. Учебное пособие в 3-х кн. – Новосибирск: НГУ, 1997. -197 с.
		
		\item Метод трассировки лучей против растеризации: новое поколение качества графики?
		[Электронный ресурс] 
		
		Режим доступа: http://www.thg.ru/graphic/ray\_tracing\_rasterization/onepage.html Последняя дата обращения: 25.12.2019
				
		\item Стандарт языка С++11 согласно ISO.
		[Электронный ресурс] 
		
		Режим доступа: https://isocpp.org/std/the-standard Последняя дата обращения: 25.12.2019
				
		\item Qt Documentation.
		[Электронный ресурс] 
		
		Режим доступа: https://doc.qt.io/ Последняя дата обращения: 25.12.2019
				
		\item std::thread
		[Электронный ресурс] 
		
		Режим доступа: https://ru.cppreference.com/w/cpp/thread/thread Последняя дата обращения: 25.12.2019
				
		\item std::mutex
		[Электронный ресурс] 
		
		Режим доступа: https://ru.cppreference.com/w/cpp/thread/mutex Последняя дата обращения: 25.12.2019
				
		\item <ctime> (time.h)
		[Электронный ресурс] 
		
		Режим доступа: http://www.cplusplus.com/reference/ctime/ Последняя дата обращения: 25.12.2019
	\end{enumerate}
		

\end{document}